# pymaceuticals-challenge
This is the class challenge for Module 5

A new pharmaceutical company that specializes in anti-cancer medications began screening potential treatments for squamous cell carcinoma (SCC), a commonly occurring form of skin cancer.

In this repo, the complete data from the company's most recent animal study in which 249 mice who were identified with SCC tumors received treatment with a range of drug regimens. Over the course of 45 days, tumor development was observed and measured. This study was designed to compare the performance of Pymaceuticals’ drug of interest, Capomulin, against the other treatment regimens options.  The code provided in this repo serves to generate all of the tables and figures needed for inclusion in the technical report of the clinical study. The results generated by the code are included in a top-level summary of the study results.

This repo includes the code in a Jupyter notebook file, a Pymaceutical Starter Results file, and a Pymaceutical Starter Analysis file.

Pymaceutical Starter Code Description
Setup
Explanation:
1.	Import Libraries: We import the necessary libraries: matplotlib.pyplot for plotting, pandas for data manipulation, and scipy.stats for statistical analysis.
2.	Data File Paths: Define the paths to your CSV files containing mouse metadata and study results.
3.	Read Data: Use pd.read_csv() to read the data from the specified file paths into Pandas DataFrames named mouse_metadata and study_results.
4.	Merge DataFrames:
o	We use pd.merge() to combine the two DataFrames.
o	The on='Mouse ID' argument specifies that the merge should be based on the common column 'Mouse ID' present in both DataFrames. This will create a new DataFrame merged_data containing all columns from both original DataFrames, with rows matched based on the 'Mouse ID'.
5.	Display Data: print(merged_data) will display the merged DataFrame, allowing you to preview the combined data.

Eliminate Duplicate Records
Explanation:
1.	Group by 'Mouse ID' and 'Time':
o	We use groupby(['Mouse ID', 'Time']) to group the merged_data DataFrame by both 'Mouse ID' and 'Time'.
2.	Count Occurrences:
o	We apply the transform('count') method to the 'Time' column within each group. This counts how many times each unique 'Time' value appears for each 'Mouse ID' combination.
3.	Identify Duplicates:
o	We create a boolean mask duplicate_mice by comparing the counts to 1. If the count is greater than 1, it means a 'Time' value is duplicated for that 'Mouse ID', indicating a duplicate entry.
4.	Create DataFrame of Duplicates:
o	We filter the merged_data DataFrame using the duplicate_mice mask to create a new DataFrame duplicate_mice_df containing only the rows with duplicate 'Time' values for a given 'Mouse ID'.

Remove Duplicate Records from the Data Set
Explanation:
1.	Identify Duplicate Mouse IDs:
o	duplicate_mice_data = pd.Series(duplicate_mice_df['Mouse ID'])
	This line extracts the 'Mouse ID' column from the duplicate_mice_df DataFrame and converts it into a Pandas Series. This Series will contain all the unique mouse IDs that have duplicates.
2.	Extract Unique Duplicate Mouse ID:
o	unique_values = duplicate_mice_data.unique()
	This line finds the unique values within the duplicate_mice_data Series. Since we're focusing on removing a specific duplicate mouse (g989), we'll use the first element of this array.
3.	Filter for Non-Duplicate Mouse IDs:
o	cleaned_data = merged_data[merged_data['Mouse ID'] != unique_values[0]]
	This is the core filtering step. It creates a new DataFrame called cleaned_data by selecting only the rows from the merged_data DataFrame where the 'Mouse ID' is not equal to the unique duplicate mouse ID (unique_values[0]).
4.	Display the Cleaned DataFrame:
o	print("\nCleaned DataFrame:")
	print(cleaned_data)
	These lines print a label and then display the contents of the cleaned_data DataFrame, which now excludes all instances of the specified duplicate mouse ID.
Explanation:
1.	num_mice = cleaned_data['Mouse ID'].nunique():
o	This line calculates the number of unique mouse IDs in the cleaned_data DataFrame. Let's break it down further:
	cleaned_data['Mouse ID']: This selects the 'Mouse ID' column from the cleaned_data DataFrame.
	.nunique(): This method is applied to the Series (the 'Mouse ID' column) and counts the number of distinct (unique) values within it. The result is stored in the variable num_mice.
2.	print(f"\nNumber of mice in the clean DataFrame: {num_mice}"):
o	This line prints the result to the console.
	\n: This is a newline character, which moves the cursor to the next line for better formatting.
	f"...": This is an f-string, a convenient way to embed variables directly within strings. The {} placeholder is replaced with the value of the num_mice variable.

Summary Statistics
Explanation:
1.	regimen_summary = cleaned_data.groupby('Drug Regimen').agg(...):
o	This line groups the cleaned_data DataFrame by the 'Drug Regimen' column.
o	.agg(...) is used to apply aggregation functions to each group.
2.	Inside the .agg() function:
o	We specify the desired summary statistics for each group:
	mean_tumor_volume=('Tumor Volume (mm3)', 'mean'): Calculates the mean of 'Tumor Volume' for each regimen.
	median_tumor_volume=('Tumor Volume (mm3)', 'median'): Calculates the median of 'Tumor Volume' for each regimen.
	variance_tumor_volume=('Tumor Volume (mm3)', 'var'): Calculates the variance of 'Tumor Volume' for each regimen.
	std_tumor_volume=('Tumor Volume (mm3)', 'std'): Calculates the standard deviation of 'Tumor Volume' for each regimen.
	sem_tumor_volume=('Tumor Volume (mm3)', lambda x: st.sem(x)): Calculates the standard error of the mean (SEM) of 'Tumor Volume' for each regimen. We use a lambda function here to apply the st.sem() function from the scipy.stats module.
3.	print(regimen_summary):
o	This line prints the resulting regimen_summary DataFrame, which will show the calculated summary statistics for each drug regimen.

Explanation:
•	alt_regimen_summary = cleaned_data.groupby('Drug Regimen').agg(...):
o	We group the cleaned_data DataFrame by 'Drug Regimen' as before.
o	The .agg() method is used to calculate multiple summary statistics simultaneously.
•	Inside the .agg() function:
o	We use concise names for the summary statistics: mean, median, variance, std, and sem.
o	The corresponding aggregation functions are applied to the 'Tumor Volume' column for each group.
•	print(alt_regimen_summary):
o	The resulting regimen_summary DataFrame is printed, displaying the calculated summary statistics for each drug regimen in a compact format.

Bar and Pie Plots
Explanation:
1.	Compute the Counts: We use value_counts() to get the number of observations per drug regimen.
2.	Create a DataFrame: We store the counts in a DataFrame to facilitate plotting.
3.	Plot Using Pandas: We use the plot method of the DataFrame to create a bar chart.
4.	Customize the Plot: We add labels, rotate the x-axis labels, and adjust the layout for better readability.
5.	Show the Plot: Finally, we display the plot using plt.show().
Explanation:
1.	regimen_counts = cleaned_data['Drug Regimen'].value_counts():
o	This line counts the occurrences of each unique value in the 'Drug Regimen' column of the cleaned_data DataFrame. The result is a Pandas Series where the index is the drug regimen and the values are the counts.
2.	plt.figure(figsize=(8, 6)):
o	This line creates a new figure for the plot and sets its size to 8 inches wide and 6 inches tall. You can adjust these values as needed.
3.	plt.bar(regimen_counts.index, regimen_counts.values):
o	This line creates a bar plot:
	regimen_counts.index: Provides the labels for the x-axis (drug regimens).
	regimen_counts.values: Provides the heights of the bars (the counts for each regimen).
4.	plt.title(...), plt.xlabel(...), plt.ylabel(...):
o	These lines set the title and labels for the x and y axes.
5.	plt.xticks(rotation=45, ha='right'):
o	This line rotates the x-axis labels by 45 degrees and aligns them to the right to improve readability.
6.	plt.tight_layout():
o	This line adjusts the plot layout to prevent labels from overlapping.
7.	plt.show():
o	This line displays the plot.
Explanation:
1.	Simplified Pie Chart Creation: The code uses the direct pandas.Series.plot(kind='pie') method, which is more concise than manually creating a pie chart using matplotlib.pyplot.pie.
2.	autopct for Percentages: The autopct='%1.1f%%' argument automatically calculates and displays the percentages on the pie slices, making the chart more informative.
3.	Figure Size: figsize=(6, 6) sets an appropriate size for the pie chart, making it easier to read.
4.	Y-label (Even for Pie Charts): While it might seem redundant for a pie chart, adding a y-label (plt.ylabel('count')) is good practice and improves clarity. The label indicates what the slices represent (counts in this case).
5.	Optional Title: plt.title() can be used to add a descriptive title to the chart.
Notes:
•	Conciseness: The pandas method is much more compact and easier to read.
•	Percentage Display: The autopct parameter handles percentage calculations and display automatically.
•	Figure Size Control: figsize helps you adjust the chart's size to make it visually appealing.
•	Clearer Labeling: Adding a y-label, even to a pie chart, makes it clearer what the data represents.




	
Quartiles, Outliers, and Box Plots
Explanation:
1.	Get Last Timepoint: The last_timepoint = cleaned_data.groupby('Mouse ID')['Timepoint'].max().reset_index() efficiently finds the maximum timepoint for each mouse.
2.	Merge to Get Final Tumor Volume: The merged_last_tp = pd.merge(...) merges the last_timepoint DataFrame with the original cleaned data to get the tumor volume at each mouse's last timepoint.
Explanation:
1.	Filter for Treatments: The filtered_data = ... line filters the merged data to include only the four specified treatment regimens.
2.	tumor_vol_data List: This list stores the tumor volume data for each treatment, making it easy to create the box plot later. It's initialized as an empty list and then populated inside the loop.
3.	Loop and IQR Calculation: The loop iterates through the treatments, calculates quartiles, IQR, bounds, and potential outliers for each treatment group. The output is printed for each treatment, clearly showing the IQR data and potential outliers.
4.	Get All Data for Subset: subset = filtered_data[filtered_data['Drug Regimen'] == treatment] gets all the data for the current treatment. This allows access to other columns like Mouse ID and Timepoint when identifying outliers.

5.	tumor_volumes Variable: The tumor volume data is stored in tumor_volumes = subset['Tumor Volume (mm3)'] to make the code cleaner and more readable.

6.	Iterate and Print Outlier Information: If outliers are found, the code iterates through the rows of the outliers DataFrame using outliers.iterrows(). Inside the loop, it prints the Mouse ID, Timepoint, and Tumor Volume (mm3) for each outlier.

7.	Using iterrows(): The for index, row in outliers.iterrows(): now uses the iterrows() method of the DataFrame. iterrows() returns both the index (row label) and the row data for each row in the DataFrame. This allows you to access and print the index along with other information for each outlier.  The index refers to the index or row label of the outlier within the Pandas Series or DataFrame that holds the tumor volume data for a treatment group.  It's simply the position of an outlier within the subset of data being analyzed for a treatment group.





Explanation:
1.	Box Plot: The plt.boxplot(tumor_vol_data, labels=treatments) creates the box plot directly from the list of tumor volume data, displaying the distribution for each treatment.
2.	flierprops Dictionary: The flierprops dictionary is used to control the appearance of the outliers (fliers) in the box plot.
3.	marker='o': This sets the marker style for the outliers to circles. You can use other markers like 's' (square), 'd' (diamond), etc.
4.	markerfacecolor='red': Sets the fill color of the outlier markers to red.
5.	markersize=8: Controls the size of the outlier markers. Adjust this value as needed.
6.	markeredgecolor='black' (Optional): Adds a black edge around the red markers to make them stand out more.

Line and Scatter Plots
Explanation:
1.	Filter Data: The code first filters the cleaned_data DataFrame to get only the rows where Mouse ID is l509 (note the correction of the typo). This filtered data is stored in the mouse_i509_data DataFrame.
2.	Create Line Plot: plt.plot() is used to create the line plot. The x-axis values are the Timepoint column, and the y-axis values are the Tumor Volume (mm3) column from the filtered data.
3.	Title and Labels: The plot is given a title, and the x and y axes are labeled for clarity. The title now specifies the drug regimen used.
Explanation:
1.	Filter for Capomulin: The capomulin_data DataFrame correctly filters for only the Capomulin regimen.
2.	Calculate Average Tumor Volume: The code groups by Mouse ID and calculates the mean of Tumor Volume (mm3) to get the average tumor volume for each mouse.
3.	Get Mouse Weights: The mouse_weights Series is created by grouping by Mouse ID and taking the first Weight (g) value for each mouse. This avoids potential issues if a mouse's weight changes over time.
4.	Scatter Plot: The plt.scatter() function uses the correctly calculated mouse_weights and avg_tumor_volume for the x and y axes, respectively.
5.	Plot Enhancements:
o	marker='o' adds circular markers to the scatter plot points.
o	facecolors='blue', edgecolors='black', and s=50 customize the marker appearance (blue fill, black edges, size 50).
6.	Title, Labels, and Grid: The plot includes a title and axis labels for better readability.

Correlation and Regression
Explanation:
1.	Correlation Calculation:
o	correlation_coefficient = round(st.pearsonr(mouse_weights, avg_tumor_volume)[0], 2): This line calculates the Pearson correlation coefficient between mouse weight (mouse_weights) and average tumor volume (avg_tumor_volume) using scipy.stats.pearsonr().
o	st.pearsonr() returns a tuple containing the correlation coefficient and the p-value. We extract the correlation coefficient using [0] and round it to two decimal places using round(..., 2).
2.	Print Correlation:
o	print(f"The correlation between...{correlation_coefficient:.2f}"): This line prints the calculated correlation coefficient, formatted to two decimal places.
3.	Linear Regression:
o	(slope, intercept, rvalue, pvalue, stderr) = st.linregress(mouse_weights, avg_tumor_volume): This performs linear regression using scipy.stats.linregress(). It takes the mouse weights and average tumor volumes as input and returns the following values:
	slope: The slope of the regression line.
	intercept: The y-intercept of the regression line.
	rvalue: The correlation coefficient (same as calculated earlier).
	pvalue: The p-value for the hypothesis test that the slope is zero.
	stderr: The standard error of the estimated slope.
o	regress_values = mouse_weights * slope + intercept: This calculates the predicted tumor volumes (regress_values) based on the linear regression equation (y = mx + b), where mouse_weights is x, slope is m, and intercept is b. These regress_values will be used to plot the regression line.
4.	Scatter Plot with Regression Line:
o	plt.figure(figsize=(8, 6)): Creates a new figure with a specified size.
o	plt.scatter(...): Creates the scatter plot of mouse weight (x-axis) vs. average tumor volume (y-axis). The marker, facecolors, edgecolors, and s arguments customize the appearance of the scatter plot markers.
o	plt.plot(mouse_weights, regress_values, "r-"): Plots the linear regression line. mouse_weights provides the x-coordinates, regress_values (calculated earlier) provides the y-coordinates, and "r-" specifies a red solid line.
o	line_eq = ...: Creates the string for the regression line equation, rounding the slope and intercept to two decimal places.
o	plt.annotate(line_eq, (20, 36), fontsize=15, color="red"): Adds the regression line equation as text annotation to the plot at coordinates (20, 36), with specified font size and color. The coordinates (20,36) might need adjustment depending on the data to avoid overlapping with data points.
o	plt.title(...), plt.xlabel(...), plt.ylabel(...): Set the plot title and axis labels.
o	plt.grid(True): Adds grid lines to the plot.
o	plt.show(): Displays the plot.

Addendum
Explanation:
1.	Imports and Setup: The code starts with necessary imports, including matplotlib.cm for colormaps.
2.	Getting Unique Treatments: It extracts unique drug regimen names from the cleaned dataframe and stores them in treatments.
3.	Line Plot:
o	A new figure is created for the line plot using plt.figure().
o	It iterates through each treatment. Inside the loop:
	It filters the data for the current treatment.
	It randomly selects one mouse from the treatment group's data to avoid overplotting using .sample(1).iloc[0].
	It plots the 'Timepoint' vs. 'Tumor Volume' for the selected mouse, labeling the line with the treatment name.
o	After the loop:
	It sets the plot title and axis labels.
	It positions the legend outside the plot using bbox_to_anchor for better readability.
	plt.tight_layout() adjusts plot elements to prevent overlap.
	plt.show() displays the plot.
4.	Scatter Plot:
o	Creates a new figure for the scatter plot.
o	Initializes scatter_colors dictionary to store colors. The colors are added inside the loop and are accessible outside the loop.
o	Iterates through treatments:
	Filters data.
	Calculates avg_tumor_volume and mouse_weights (mean tumor volume and first recorded weight) grouped by "Mouse ID."
	Creates a colormap and colors each point.
	Generates a scatter plot.
o	Sets title, labels, legend (outside), adjusts layout, and displays the plot.
5.	Correlation and Regression (Individual Plots):
o	Iterates through treatments.
o	Filters data.
o	Calculates and prints the correlation coefficient.
o	Performs linear regression using st.linregress.
o	Calculates regress_values for the regression line.
o	Creates a new figure for each treatment's plot. This ensures that each plot opens in a new window.
o	Plots the scatter and regression line, annotates the regression equation.
o	Sets title, labels, and displays the plot.
6.	Combined Regression Plot (Single Plot):
o	Creates a new figure for the combined plot.
o	Creates the color map.
o	Iterates through treatments, performing the same calculations as the individual regression plots but plotting everything on the same figure.
o	Uses color coding for scatter points and regression lines based on the chosen colormap.
o	Sets title, labels, legend, adds a grid, adjusts layout, and displays the plot.

